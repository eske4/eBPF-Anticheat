#include "module_handler.h"
#include <bpf/libbpf.h>
#include <iostream>

int module_handler::LoadAndAttachAll() {
  std::cout << "Starting BPF program deployment..." << std::endl;
  int err = 0;

  // 1. Open the BPF object: Initialize the BPF object from the compiled
  // bytecode. The anticheat_bpf__open() function is generated by the skeleton.
  skel_obj.reset(module_tracker__open());
  if (!skel_obj) {
    std::cerr << "ERROR: Failed to open BPF skeleton object." << std::endl;
    return -1;
  }

  // 2. Load the BPF object: Verifies the code, allocates maps, and loads
  // programs into the kernel.
  err = module_tracker__load(skel_obj.get());
  if (err) {
    std::cerr << "ERROR: Failed to load BPF programs into kernel: " << err
              << std::endl;
    // The unique_ptr will call the custom deleter on destruction if we don't
    // reset it, but explicit handling is often cleaner here.
    skel_obj.reset();
    return err;
  }

  // 3. Attach the BPF programs: Hooks the programs (e.g., to kprobes, LSM) and
  // starts monitoring.
  err = module_tracker__attach(skel_obj.get());
  if (err) {
    std::cerr << "ERROR: Failed to attach BPF programs to hook points: " << err
              << std::endl;
    skel_obj.reset();
    return err;
  }

  std::cout << "SUCCESS: eBPF programs loaded and attached." << std::endl;
  return 0;
}

// --- Detach and Unload Implementation ---
void module_handler::DetachAndUnloadAll() {
  // Check if the unique_ptr holds a valid object before attempting cleanup.
  if (skel_obj) {
    // The bpf__destroy function automatically handles detaching programs and
    // freeing maps. The unique_ptr's custom deleter will run
    // module_tracker__destroy() when the skel_obj is destroyed, but we can call
    // reset() explicitly here for immediate and controlled cleanup.

    // We explicitly destroy the object, which detaches everything.
    module_tracker__destroy(skel_obj.release());
    std::cout << "eBPF programs detached and unloaded." << std::endl;
  }
}

module_handler::~module_handler() { DetachAndUnloadAll(); }
